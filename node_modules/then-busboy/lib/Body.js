"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _objectDeepFromEntries = _interopRequireDefault(require("object-deep-from-entries"));

var _formdataNode = _interopRequireDefault(require("formdata-node"));

var _Field = _interopRequireDefault(require("./Field"));

var _normalizeFields = _interopRequireDefault(require("./util/normalizeFields"));

var _pathToFieldname = _interopRequireDefault(require("./util/pathToFieldname"));

var _isFile = _interopRequireDefault(require("./util/isFile"));

let _Symbol$iterator;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

_Symbol$iterator = Symbol.iterator;

/**
 * @api public
 */
class Body {
  /**
   * Check if given value is Body instance
   *
   * @param {any} value
   *
   * @return {boolean}
   */
  static isBody(value) {
    return value instanceof Body;
  }
  /**
   * Create a new Body from given entries.
   * An alias of `new Body(entries)`
   *
   * @param {Array<[string[], any]>}
   *
   * @return {Body}
   */


  static from(entries) {
    return new Body(entries);
  }
  /**
   * Return an object with data taken from given entries or Body
   *
   * @param {Array<[string[], any]>}
   *
   * @return {object}
   */


  static json(value) {
    return Body.isBody(value) ? value.json() : Body.from(value).json();
  }
  /**
   * Return a FormData instance with data taken from given entries or Body
   *
   * @param {Array<[string[], any]>}
   *
   * @return {FormData}
   */


  static formData(value) {
    return Body.isBody(value) ? value.formData() : Body.from(value).formData();
  }
  /**
   * Create a new Body from given entries
   *
   * @param {Array<[string[], any]>}
   */


  constructor(_entries) {
    _defineProperty(this, "entries", () => this.__entries);

    _defineProperty(this, "map", (fn, ctx = null) => {
      const entries = [];

      for (const [path, field] of this.entries()) {
        const name = (0, _pathToFieldname.default)(path);
        let newField = fn.call(ctx, field, name, path, this.entries());

        if (!(newField instanceof _Field.default) && !(0, _isFile.default)(field)) {
          newField = new _Field.default(_objectSpread(_objectSpread({}, field), {}, {
            value: newField
          }));
        }

        entries.push([path, newField]);
      }

      return Body.from(entries);
    });

    _defineProperty(this, "forEach", (fn, ctx = null) => void this.map(fn, ctx));

    _defineProperty(this, "filter", (fn, ctx = null) => {
      const entries = [];

      for (const [path, field] of this.entries()) {
        const name = (0, _pathToFieldname.default)(path);

        if (fn.call(ctx, field, name, path, this.entries())) {
          entries.push([path, field]);
        }
      }

      return Body.from(entries);
    });

    _defineProperty(this, "json", () => (0, _objectDeepFromEntries.default)((0, _normalizeFields.default)(this.entries())));

    _defineProperty(this, "formData", () => {
      const fd = new _formdataNode.default();

      for (const [path, field] of this.entries()) {
        const name = (0, _pathToFieldname.default)(path);

        if ((0, _isFile.default)(field)) {
          fd.set(name, field.stream(), field.filename);
        } else {
          fd.set(name, field.value);
        }
      }

      return fd;
    });

    // TODO: Allow to apply fields as scalars
    this.__entries = _entries.slice();
  }
  /**
   * Return an amount of entries and files in current Body instance
   *
   * @return {number}
   */


  get length() {
    return this.__entries.length;
  }
  /**
   * Return a new Body that contains fields only
   *
   * @return {Body}
   */


  get fields() {
    return this.filter(field => (0, _isFile.default)(field) === false);
  }
  /**
   * Return a new Body that contains files only
   *
   * @return {Body}
   */


  get files() {
    return this.filter(field => (0, _isFile.default)(field));
  }

  [_Symbol$iterator]() {
    return this.values();
  }
  /**
   * Return an iterator allows to go through the Body fields path
   */


  *paths() {
    for (const [path] of this.entries()) {
      yield path;
    }
  }
  /**
   * Return an iterator allows to go through the Body fields name
   */


  *names() {
    for (const [path] of this.entries()) {
      yield (0, _pathToFieldname.default)(path);
    }
  }
  /**
   * Return an iterator allows to go through the Body values
   */


  *values() {
    for (const [, value] of this.entries()) {
      yield value;
    }
  }
  /**
   * Return an array of entries in current Body instance
   *
   * @return {Array<[string[], any]>}
   */


}

var _default = Body;
exports.default = _default;