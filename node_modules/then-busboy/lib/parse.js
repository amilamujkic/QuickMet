"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _http = _interopRequireDefault(require("http"));

var _busboy = _interopRequireDefault(require("busboy"));

var _lodash = _interopRequireDefault(require("lodash.merge"));

var _invariant = _interopRequireDefault(require("@octetstream/invariant"));

var _arrayRunWaterfall = _interopRequireDefault(require("./util/arrayRunWaterfall"));

var _isPlainObject = _interopRequireDefault(require("./util/isPlainObject"));

var _mapListeners = _interopRequireDefault(require("./util/mapListeners"));

var _getType = _interopRequireDefault(require("./util/getType"));

var _Body = _interopRequireDefault(require("./Body"));

var _onFile = _interopRequireDefault(require("./listener/onFile"));

var _onField = _interopRequireDefault(require("./listener/onField"));

var _onFilesLimit = _interopRequireDefault(require("./listener/onFilesLimit"));

var _onPartsLimit = _interopRequireDefault(require("./listener/onPartsLimit"));

var _onFieldsLimit = _interopRequireDefault(require("./listener/onFieldsLimit"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const initializers = {
  onFile: _onFile.default,
  onField: _onField.default,
  onFilesLimit: _onFilesLimit.default,
  onPartsLimit: _onPartsLimit.default,
  onFieldsLimit: _onFieldsLimit.default
};
const defaults = {
  restoreTypes: true
};
/**
 * @api private
 */

const exec = ({
  request,
  options
}) => new Promise((resolve, reject) => {
  const entries = [];
  const busboy = new _busboy.default(options);

  const fulfill = (err, entry) => err ? reject(err) : entries.push(entry);

  const listeners = (0, _mapListeners.default)(initializers, fn => fn(options, fulfill));

  const unsubscribe = () => (0, _mapListeners.default)(listeners, (fn, name) => busboy.removeListener(name, fn));

  function onFinish() {
    unsubscribe();
    resolve(entries);
  }

  function onError(err) {
    unsubscribe();
    reject(err);
  }

  (0, _mapListeners.default)(listeners, (fn, name) => busboy.on(name, fn));
  busboy.once("error", onError).once("finish", onFinish);
  request.pipe(busboy);
});
/**
 * Promise-based wrapper around Busboy. Inspired by async-busboy.
 * You'll get exactly what you've sent from your client app.
 * All files and other fields in a single object.
 *
 * @param {http.IncomingMessage} request â€“ HTTP request object
 * @param {object} [options = {}] - then-busboy options
 *
 * @return {Promise<Body>}
 *
 * @api public
 *
 * @example
 *
 * // Simplest Koa.js middleware:
 * import {parse, Body} from "then-busboy"
 *
 * const toLowerCase = string => String.prototype.toLowerCase.call(string)
 *
 * const multipart = () => async (ctx, next) => {
 *   if (["post", "put"].includes(toLowerCase(ctx.method)) === false) {
 *     return next()
 *   }
 *
 *   if (ctx.is("multipart/form-data") === false) {
 *     return next()
 *   }
 *
 *   ctx.request.body = await busboy(ctx.req).then(Body.json)
 *
 *   await next()
 * }
 *
 * export default multipart
 */


async function parse(request, options = {}) {
  (0, _invariant.default)(!(request instanceof _http.default.IncomingMessage), TypeError, "Request must be an instance of http.IncomingMessage. Received %s", (0, _getType.default)(request));
  (0, _invariant.default)(!(0, _isPlainObject.default)(options), TypeError, "Options must be an object. Received %s", (0, _getType.default)(options));
  options = (0, _lodash.default)({}, defaults, options, {
    headers: request.headers
  });
  return (0, _arrayRunWaterfall.default)([exec, _Body.default.from], {
    request,
    options
  });
}

var _default = parse;
exports.default = _default;